/**
 * Start up a local dev server.
 */

const args = process.argv.slice(2);

// Set the environment if it isn't set.
if (process.env.NODE_ENV === undefined) {
  // tslint:disable-next-line:no-object-mutation
  process.env.NODE_ENV = args.includes('--production') || args.includes('-p')
    ? 'production'
    : 'development';
}

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', (error) => {
  // tslint:disable-next-line:no-throw
  throw error;
});

import chalk from 'chalk';
import webpack from 'webpack';
import WebpackDevServer from 'webpack-dev-server';

import checkRequiredFiles from 'react-dev-utils/checkRequiredFiles';
import clearConsole from 'react-dev-utils/clearConsole';
import openBrowser from 'react-dev-utils/openBrowser';
import {
  choosePort,
  createCompiler,
  prepareProxy,
  prepareUrls
} from 'react-dev-utils/WebpackDevServerUtils';

import { loadClientEnvironment } from '../config/env';
import * as paths from '../config/paths';
import { getDevServerConfig } from '../config/webpackDevServer.config';

const defaultPort = 3000;

(async (): Promise<void> => {
  // Load the environment variables before doing anything else.
  await loadClientEnvironment();

  // Warn and crash if required files are missing.
  if (!checkRequiredFiles([paths.APP_HTML, paths.APP_INDEX])) {
    return Promise.reject(new Error('Missing required files.'));
  }

  const host =
    process.env.HOST === undefined
    ? '0.0.0.0'
    : process.env.HOST;

  const requestedPort =
    process.env.PORT === undefined
    ? defaultPort
    : parseInt(process.env.PORT, 10);

  if (process.env.HOST !== undefined) {
    console.info(
      [
        `${chalk.cyan(
          `Attempting to bind to HOST environment variable: ${
            chalk.yellow(chalk.bold(process.env.HOST))
          }`
        )}`,
        `If this was unintentional, check that you haven't mistakenly set it in your shell.`,
        `Learn more here: ${chalk.yellow('https://bit.ly/2mwWSwH')}`,
        ``
      ].join('\n')
    );
  }

  // We attempt to use the default port but if it is busy, we offer the user to
  // run on a different port. `choosePort()` Promise resolves to the next free port.
  const port = await choosePort(host, requestedPort);

  // Don't have a port?
  if (port === null) {
    return Promise.reject(new Error('Could not find a port to run on.'));
  }

  const packageJson = await import(paths.APP_PACKAGE_DOT_JSON);

  const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
  const appName = packageJson.name;
  const urls = prepareUrls(protocol, host, port);

  // Load proxy config
  const proxySetting = packageJson.proxy;
  const proxyConfig = prepareProxy(proxySetting, paths.APP_PUBLIC);

  // Serve webpack assets generated by the compiler over a web sever.
  const [webpackConfig, serverConfig] = await getDevServerConfig(
    proxyConfig,
    urls.lanUrlForConfig
  );

  // Create a webpack compiler that is configured with custom messages.
  const compiler = createCompiler(webpack, webpackConfig, appName, urls, true);

  const devServer = new WebpackDevServer(compiler, serverConfig);

  // Launch WebpackDevServer.
  devServer.listen(port, host, (error) => {
    if (error === undefined) {
      if (process.stdout.isTTY === true) {
        clearConsole();
      }
      console.info(chalk.cyan('Starting the development server...\n'));
      openBrowser(urls.localUrlForBrowser);
    } else {
      console.error(error.message);
    }
  });

  (['SIGINT', 'SIGTERM'] as Array<NodeJS.Signals>)
    .forEach((sig) => {
      process.on(sig, () => {
        devServer.close();
        process.exit();
      });
    });
})()
  .catch((error) => {
    if (error !== undefined && error.message !== undefined) {
      console.error(error.message);
    }
    process.exit(1);
  });
